export PATH="$PATH:$HOME/.vscode-server/bin/74b1f979648cc44d385a2286793c226e611f59e7/bin/"

violatale --  игнорирует оптимизации для изменяемы объектов
inline -- вставлять код, но сейчас можно не делать, компилятор сам сделает, если можно
const -- внутри функции нельзя изменять члены данного класса, кроме помеченных mutable
static -- вызывает функцию без создания объекта

класс является ограничителем области видимости

Конструктор и Деструктор

Деструктор освобождает ресурсы
    Вызывается после вызова delete

Конструктор -- явная инициализация + фаза вычислений(тело)
    не может иметь const и volatile ??

Время жизни начинается от начала вызова конструктора

Вызов деструкторов в обратном порядке от конструктора

Инициализация без конструктора, позиционная инициализация(всё public(structure))
    Не стоит использовать, трудно отлавливать ошибки
    Плюс нет инкапсуляции

Конструктор по умолчанию можно задать с параметрами, но НУЖНО, чтобы параметры имели стандартное
    значение
    Стоит избегать, так как труднее отслеживать ошибки

При создании массивов и динамических указателей вызывается конструктора по умолчанию

explicit -- явно сконструировать по отношению к конструктору

Если массив, то можно явно вызывать конструктор для данных объектов

Закрытые и защищенные конструкторы

Private or protected -- защищенный или закрытый 
    нужен для создания объекта данного класса с использованием других функций
    не хотим копирования объекта
    В паттерне синглтон используется данный тип конструктора

    Можно явно указать какой конструктор использовать (инет в помощь)

Операции преобразования подверждены ошибкам при написании
    так как можно не заметить, что мы сделали
    если используем, то стоит понимать, насколька она нужна
    если есть сомнения, то лучше использовать функцию вместо operator int --> to_int

При инициализации вызывайте также, как и записаны переменные 
Использовать почленную иницализацию лучше, чем внутри тела цикла вызывать, так как
    список иницализации вызывается раньше, а значит в теле цикла всё будет иницализировано

Деструктор вызывается при выходе из области видимости или delete 
    Явно вызываем, если нужно разместить в опеределённом участке памяти, вызванном
    заранее

Скобочная инициализация 
    Можно использовать фигурные скобки
    int n{21};

Конструктор переноса помогает скопировать в другой класс что то, а у нас просто 
    nullptr
    && это специальный тип данных для передачи ссылки при конструкторе переноса

std::move
    преобразовываем наш объект к && объекту
    просто каст к нужному типу
    если будет const объект, то просто будет копирование, так как не будет перемещения

    Пример
    alp1 = foo(Alpha()) -- создание временного объекта, там rvalue, тч там &&, то есть
    конструируется объекта альфа с помощью переноса

    В ДЗ имеет смысл использовать перенос, а не копирование!!

