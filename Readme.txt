export PATH="$PATH:$HOME/.vscode-server/bin/74b1f979648cc44d385a2286793c226e611f59e7/bin/"

volitale --  игнорирует оптимизации для изменяемы переменной (при указании к переменной)
    для методов в самом конце есть пример

inline -- вставлять код, но сейчас можно не делать, компилятор сам сделает, если можно
const -- внутри функции нельзя изменять члены данного класса, кроме помеченных mutable
static -- вызывает функцию без создания объекта

класс является ограничителем области видимости

Конструктор и Деструктор

Деструктор освобождает ресурсы
    Вызывается после вызова delete

Конструктор -- явная инициализация + фаза вычислений(тело)
    не может иметь const и volatile ??

Время жизни начинается от начала вызова конструктора

Вызов деструкторов в обратном порядке от конструктора

Инициализация без конструктора, позиционная инициализация(всё public(structure))
    Не стоит использовать, трудно отлавливать ошибки
    Плюс нет инкапсуляции

Конструктор по умолчанию можно задать с параметрами, но НУЖНО, чтобы параметры имели стандартное
    значение
    Стоит избегать, так как труднее отслеживать ошибки

При создании массивов и динамических указателей вызывается конструктора по умолчанию

explicit -- явно сконструировать по отношению к конструктору

Если массив, то можно явно вызывать конструктор для данных объектов

Закрытые и защищенные конструкторы

Private or protected -- защищенный или закрытый 
    нужен для создания объекта данного класса с использованием других функций
    не хотим копирования объекта
    В паттерне синглтон используется данный тип конструктора

    Можно явно указать какой конструктор использовать (инет в помощь)

Операции преобразования подверждены ошибкам при написании
    так как можно не заметить, что мы сделали
    если используем, то стоит понимать, насколька она нужна
    если есть сомнения, то лучше использовать функцию вместо operator int --> to_int

При инициализации вызывайте также, как и записаны переменные 
Использовать почленную иницализацию лучше, чем внутри тела цикла вызывать, так как
    список иницализации вызывается раньше, а значит в теле цикла всё будет иницализировано

Деструктор вызывается при выходе из области видимости или delete 
    Явно вызываем, если нужно разместить в опеределённом участке памяти, вызванном
    заранее

Скобочная инициализация 
    Можно использовать фигурные скобки
    int n{21};

Конструктор переноса помогает скопировать в другой класс что то, а у нас просто 
    nullptr
    && это специальный тип данных для передачи ссылки при конструкторе переноса

std::move
    преобразовываем наш объект к && объекту
    просто каст к нужному типу
    если будет const объект, то просто будет копирование, так как не будет перемещения

    Пример
    alp1 = foo(Alpha()) -- создание временного объекта, там rvalue, тч там &&, то есть
    конструируется объекта альфа с помощью переноса

    В ДЗ имеет смысл использовать перенос, а не копирование!!


Реализация copy and swap сделает так, что все корректно будет создано!

Есть автогенерация, можно её убрать
    Sample() = delete;

Принудительная автогенерация
    ~Sample() = default;

Copy elision (подавление копирования)
    RVO - return value optimisation
        возращает объект без копирования 
    NRVO - named RVO
        don't destroy object when leaving function

Правило 3!!!!
    Конструктор копирования, операцию присваивания, деструкторов
После семантики переноса
    Правило 5
        Путём копирования,переноса, явно конструктор переноса, деструктор, оператор присваивания
Можно прописать стандартно, но нужно сделать это явно!
Правило 0
    если нет нужды писать ни один из вышеперечисленных, то пусть это делается автоматом

Перегрузка операторов
    С 20 стандарта появился автоматический способ генерации большинства методов сравнения
    Операция космического корабля
    Ссылка есть на слайде

Принципы SOLID
    SRP
        У любого класса одна и только одна зона ответственности
    OCP
        Закрыт для изменения, открыт для модификации



github есть RVO and NRVO try this code
C++11



------------------------
struct A {
    void bar() {
        std::cout << "bar1" << std::endl;
    };
    void bar() volatile {
        std::cout << "bar2" << std::endl;
    };
}

int main() {
    A a;
    a.bar();
    A a2;
    a.bar();
}

выведет для не volatile переменной функцию 1, а для A2 bar volatile





-----------
ссылки a_=b
Не стоит использовать переменные ссылочного типа ВАЖНО

struct A {
    A(int& a) : a_(a) {}
    void bar() {
        std::cout << "bar1" << std::endl;
    };
    
    int & a_;
}

int main() {
    int b = 42;
    A a(b);
    b = 36;
    std::cout << a.a_;
}
